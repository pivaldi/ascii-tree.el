;;; ascii-tree.el --- Convert between ASCII trees and Org/Markdown formats -*- lexical-binding: t; -*-

;; Copyright (C) 2026

;; Author: Philippe IVALDI (With the help of an AI)
;; Version: 1.0.0
;; Package-Requires: ((emacs "27.1"))
;; Keywords: convenience, tools, text, tree
;; URL: https://github.com/pivaldi/ascii-tree.el

;;; Commentary:

;; This package provides tools to seamlessly convert standard ASCII directory
;; trees (like those generated by the `tree` command) into Markdown or Org-mode
;; outlines, and reliably convert them back into pixel-perfect ASCII trees.
;;
;; Features:
;; - Parses structure depths dynamically without relying on specific indent sizes.
;; - Supports multi-line comments and inline code blocks (`#[code lang]` / `#[endcode]`).
;; - Idempotent round-tripping: Tree -> Org/MD -> Tree is 100% loss-less.
;; - Intelligently reconstructs terminal pipes (`│`, `├──`, `└──`) and blank line geometry.
;;
;; Usage:
;; Highlight an ASCII tree or Markdown/Org text and run one of the provided interactive
;; commands, e.g., `M-x ascii-tree-to-md` or `M-x ascii-tree-from-md`.

;;; Code:

;;;###autoload
(defun ascii-tree-to-md (start end)
  "Convert an ASCII tree structure to Markdown format.
The result is placed in a new buffer called *ascii-tree-md*."
  (interactive "r")
  (let* ((text (buffer-substring-no-properties start end))
         (text (replace-regexp-in-string "\n+\\'" "" text))
         (lines (split-string text "\n"))
         (output-buf (get-buffer-create "*ascii-tree-md*"))
         (accum nil)
         (flush-accum 
          (lambda ()
            (save-match-data 
              (when accum
                (with-current-buffer output-buf
                  (setq accum (nreverse accum))
                  (let ((in-code-block nil))
                    (dolist (line accum)
                      (cond
                       ((string-match "^[ \t\240]*\\[code[ \t]*\\(.*\\)\\][ \t\240]*$" line)
                        (setq in-code-block t)
                        (let ((lang (match-string 1 line)))
                          (insert "```" (if (string= lang "") "" lang) "\n")))
                       ((string-match-p "^[ \t\240]*\\[endcode\\][ \t\240]*$" line)
                        (setq in-code-block nil)
                        (insert "```\n"))
                       ((string-match-p "^[ \t\240]*$" line)
                        (if in-code-block (insert "\n") (insert ":\n")))
                       (t (insert line "\n")))))
                  (setq accum nil)))))))

    (with-current-buffer output-buf
      (erase-buffer)
      (if (fboundp 'markdown-mode) (markdown-mode) (text-mode)))

    (dolist (line lines)
      (cond
       ((string-match "^\\([│ \t\240]*\\)[├└]──[ \t\240]*\\([^ \t\240#]+\\)\\([ \t\240]*#[ \t\240]*\\(.*\\)\\)?$" line)
        (let* ((prefix (match-string 1 line))
               (file (match-string 2 line))
               (desc (match-string 4 line))
               (clean-prefix (replace-regexp-in-string "[\t]" "    " prefix))
               (clean-prefix (replace-regexp-in-string "[\240]" " " clean-prefix))
               (level (1+ (/ (length clean-prefix) 4))))
          (funcall flush-accum)
          (with-current-buffer output-buf
            (if desc
                (insert (make-string (1+ level) ?#) " " file " -- " desc "\n")
              (insert (make-string (1+ level) ?#) " " file "\n")))))
       ((string-match "^[│ \t\240]*#[ \t\240]?\\(.*\\)$" line)
        (push (match-string 1 line) accum))
       ((string-match-p "^[│ \t\240]*$" line)
        (funcall flush-accum)
        (with-current-buffer output-buf (insert "\n")))
       ((and (not (string-match-p "[│├└#]" line)) (not (string-match-p "^[ \t\240]*$" line)))
        (let ((title (replace-regexp-in-string "\\`[ \t\240\n\r]+\\|[ \t\240\n\r]+\\'" "" line)))
          (funcall flush-accum)
          (with-current-buffer output-buf (insert "# " title "\n"))))))
    (funcall flush-accum)
    (switch-to-buffer output-buf)))

;;;###autoload
(defun ascii-tree-from-md (start end)
  "Convert a Markdown tree back into an ASCII tree structure.
The result is placed in a new buffer called *ascii-tree-tree*."
  (interactive "r")
  (let* ((text (buffer-substring-no-properties start end))
         (text (replace-regexp-in-string "\n+\\'" "" text))
         (lines (split-string text "\n"))
         (output-buf (get-buffer-create "*ascii-tree-tree*"))
         (heading-info nil)
         (last-sibling-hash (make-hash-table :test 'eq))
         (is-last-at-level (make-vector 100 nil))
         (next-heading-level-array (make-vector (length lines) 0))
         (current-level 0)
         (in-code-block nil))

    (let ((idx (1- (length lines))) (nxt-lvl 0))
      (while (>= idx 0)
        (aset next-heading-level-array idx nxt-lvl)
        (when (string-match "^\\(#+\\)[ \t]+" (nth idx lines))
          (setq nxt-lvl (1- (length (match-string 1 (nth idx lines))))))
        (setq idx (1- idx))))
    (let ((idx 0))
      (dolist (line lines)
        (when (string-match "^\\(#+\\)[ \t]+" line)
          (push (cons idx (1- (length (match-string 1 line)))) heading-info))
        (setq idx (1+ idx))))
    (setq heading-info (nreverse heading-info))

    (let ((tail heading-info))
      (while tail
        (let* ((curr (car tail)) (idx (car curr)) (lvl (cdr curr)) (is-last t) (lookahead (cdr tail)))
          (while lookahead
            (let ((next-lvl (cdr (car lookahead))))
              (cond ((< next-lvl lvl) (setq lookahead nil))
                    ((= next-lvl lvl) (setq is-last nil) (setq lookahead nil))
                    (t (setq lookahead (cdr lookahead))))))
          (puthash idx is-last last-sibling-hash)
          (setq tail (cdr tail)))))

    (let ((make-prefix
           (lambda (type current-idx)
             (let ((res "") (d 1) (nxt (aref next-heading-level-array current-idx)))
               (cond
                ((eq type 'node)
                 (while (< d current-level)
                   (if (aref is-last-at-level d) (setq res (concat res "    ")) (setq res (concat res "│   ")))
                   (setq d (1+ d)))
                 (when (> current-level 0)
                   (if (aref is-last-at-level current-level) (setq res (concat res "└── ")) (setq res (concat res "├── "))))
                 res)
                ((eq type 'text)
                 (let ((target (max current-level nxt)))
                   (while (<= d target)
                     (if (<= d current-level)
                         (if (aref is-last-at-level d) (setq res (concat res "    ")) (setq res (concat res "│   ")))
                       (setq res (concat res "│   ")))
                     (setq d (1+ d)))
                   res))
                ((eq type 'blank)
                 (let ((target nxt))
                   (while (< d target)
                     (if (aref is-last-at-level d) (setq res (concat res "    ")) (setq res (concat res "│   ")))
                     (setq d (1+ d)))
                   (when (> target 0) (setq res (concat res "│   ")))
                   res)))))))

      (with-current-buffer output-buf (erase-buffer))
      (let ((idx 0))
        (dolist (line lines)
          (cond
           ((and in-code-block (string-match-p "^[ \t]*```[ \t]*$" line))
            (setq in-code-block nil)
            (with-current-buffer output-buf (insert (funcall make-prefix 'text idx) "#[endcode]\n")))
           ((and (not in-code-block) (string-match "^[ \t]*```\\(.*\\)$" line))
            (setq in-code-block t)
            (with-current-buffer output-buf (insert (funcall make-prefix 'text idx) "#[code " (match-string 1 line) "]\n")))
           ((and (not in-code-block) (string-match "^\\(#+\\)[ \t]+\\(.*?\\)[ \t]*--[ \t]*\\(.*\\)$" line))
            (let* ((hashes (match-string 1 line)) (file (match-string 2 line)) (desc (match-string 3 line)) (level (1- (length hashes))))
              (if (= level 0)
                  (with-current-buffer output-buf (insert file "  # " desc "\n"))
                (setq current-level level)
                (aset is-last-at-level level (gethash idx last-sibling-hash))
                (with-current-buffer output-buf (insert (funcall make-prefix 'node idx) file "  # " desc "\n")))))
           ((and (not in-code-block) (string-match "^\\(#+\\)[ \t]+\\(.*\\)$" line))
            (let* ((hashes (match-string 1 line)) (file (match-string 2 line)) (level (1- (length hashes))))
              (if (= level 0)
                  (with-current-buffer output-buf (insert file "\n"))
                (setq current-level level)
                (aset is-last-at-level level (gethash idx last-sibling-hash))
                (with-current-buffer output-buf (insert (funcall make-prefix 'node idx) file "\n")))))
           ((and (not in-code-block) (string-match-p "^[ \t]*:[ \t]*$" line))
            (with-current-buffer output-buf (insert (funcall make-prefix 'text idx) "#\n")))
           ((string-match-p "^[ \t]*$" line)
            (with-current-buffer output-buf
              (let ((prefix (replace-regexp-in-string "[ \t]+$" "" (funcall make-prefix (if in-code-block 'text 'blank) idx))))
                (if (string= prefix "") (insert "\n") (insert prefix "\n")))))
           (t
            (let ((content line))
              (unless in-code-block (setq content (replace-regexp-in-string "^[ \t]\\{1,4\\}" "" content)))
              (with-current-buffer output-buf (insert (funcall make-prefix 'text idx) "# " content "\n")))))
          (setq idx (1+ idx)))))
    (switch-to-buffer output-buf)))

;;;###autoload
(defun ascii-tree-to-org (start end)
  "Convert an ASCII tree structure to Org-mode format.
The result is placed in a new buffer called *ascii-tree-org*."
  (interactive "r")
  (let* ((text (buffer-substring-no-properties start end))
         (text (replace-regexp-in-string "\n+\\'" "" text))
         (lines (split-string text "\n"))
         (output-buf (get-buffer-create "*ascii-tree-org*"))
         (accum nil)
         (flush-accum 
          (lambda ()
            (save-match-data 
              (when accum
                (with-current-buffer output-buf
                  (setq accum (nreverse accum))
                  (let ((in-code-block nil))
                    (dolist (line accum)
                      (cond
                       ((string-match "^[ \t\240]*\\[code[ \t]*\\(.*\\)\\][ \t\240]*$" line)
                        (setq in-code-block t)
                        (let ((lang (match-string 1 line)))
                          (insert "#+BEGIN_SRC " (if (string= lang "") "" lang) "\n")))
                       ((string-match-p "^[ \t\240]*\\[endcode\\][ \t\240]*$" line)
                        (setq in-code-block nil)
                        (insert "#+END_SRC\n"))
                       ((string-match-p "^[ \t\240]*$" line)
                        (if in-code-block (insert "\n") (insert ":\n")))
                       (t (insert line "\n")))))
                  (setq accum nil)))))))

    (with-current-buffer output-buf
      (erase-buffer)
      (org-mode))

    (dolist (line lines)
      (cond
       ((string-match "^\\([│ \t\240]*\\)[├└]──[ \t\240]*\\([^ \t\240#]+\\)\\([ \t\240]*#[ \t\240]*\\(.*\\)\\)?$" line)
        (let* ((prefix (match-string 1 line))
               (file (match-string 2 line))
               (desc (match-string 4 line))
               (clean-prefix (replace-regexp-in-string "[\t]" "    " prefix))
               (clean-prefix (replace-regexp-in-string "[\240]" " " clean-prefix))
               (level (1+ (/ (length clean-prefix) 4))))
          (funcall flush-accum)
          (with-current-buffer output-buf
            (if desc
                (insert (make-string level ?*) " " file " -- " desc "\n")
              (insert (make-string level ?*) " " file "\n")))))
       ((string-match "^[│ \t\240]*#[ \t\240]?\\(.*\\)$" line)
        (push (match-string 1 line) accum))
       ((string-match-p "^[│ \t\240]*$" line)
        (push "" accum))
       ((and (not (string-match-p "[│├└#]" line)) (not (string-match-p "^[ \t\240]*$" line)))
        (let ((title (replace-regexp-in-string "\\`[ \t\240\n\r]+\\|[ \t\240\n\r]+\\'" "" line)))
          (funcall flush-accum)
          (with-current-buffer output-buf (insert "#+title: " title "\n"))))))
    (funcall flush-accum)
    (switch-to-buffer output-buf)))

;;;###autoload
(defun ascii-tree-from-org (start end)
  "Convert an Org-mode tree back into an ASCII tree structure.
The result is placed in a new buffer called *ascii-tree-tree*."
  (interactive "r")
  (let* ((text (buffer-substring-no-properties start end))
         (text (replace-regexp-in-string "\n+\\'" "" text))
         (lines (split-string text "\n"))
         (output-buf (get-buffer-create "*ascii-tree-tree*"))
         (heading-info nil)
         (last-sibling-hash (make-hash-table :test 'eq))
         (is-last-at-level (make-vector 100 nil))
         (next-heading-level-array (make-vector (length lines) 0))
         (current-level 0)
         (in-code-block nil))

    (let ((idx (1- (length lines))) (nxt-lvl 0))
      (while (>= idx 0)
        (aset next-heading-level-array idx nxt-lvl)
        (when (string-match "^\\(\\*+\\)[ \t]+" (nth idx lines))
          (setq nxt-lvl (length (match-string 1 (nth idx lines)))))
        (setq idx (1- idx))))
    (let ((idx 0))
      (dolist (line lines)
        (when (string-match "^\\(\\*+\\)[ \t]+" line)
          (push (cons idx (length (match-string 1 line))) heading-info))
        (setq idx (1+ idx))))
    (setq heading-info (nreverse heading-info))

    (let ((tail heading-info))
      (while tail
        (let* ((curr (car tail)) (idx (car curr)) (lvl (cdr curr)) (is-last t) (lookahead (cdr tail)))
          (while lookahead
            (let ((next-lvl (cdr (car lookahead))))
              (cond ((< next-lvl lvl) (setq lookahead nil))
                    ((= next-lvl lvl) (setq is-last nil) (setq lookahead nil))
                    (t (setq lookahead (cdr lookahead))))))
          (puthash idx is-last last-sibling-hash)
          (setq tail (cdr tail)))))

    (let ((make-prefix
           (lambda (type current-idx)
             (let ((res "") (d 1) (nxt (aref next-heading-level-array current-idx)))
               (cond
                ((eq type 'node)
                 (while (< d current-level)
                   (if (aref is-last-at-level d) (setq res (concat res "    ")) (setq res (concat res "│   ")))
                   (setq d (1+ d)))
                 (when (> current-level 0)
                   (if (aref is-last-at-level current-level) (setq res (concat res "└── ")) (setq res (concat res "├── "))))
                 res)
                ((eq type 'text)
                 (let ((target (max current-level nxt)))
                   (while (<= d target)
                     (if (<= d current-level)
                         (if (aref is-last-at-level d) (setq res (concat res "    ")) (setq res (concat res "│   ")))
                       (setq res (concat res "│   ")))
                     (setq d (1+ d)))
                   res))
                ((eq type 'blank)
                 (let ((target nxt))
                   (while (< d target)
                     (if (aref is-last-at-level d) (setq res (concat res "    ")) (setq res (concat res "│   ")))
                     (setq d (1+ d)))
                   (when (> target 0) (setq res (concat res "│   ")))
                   res)))))))

      (with-current-buffer output-buf (erase-buffer))
      (let ((idx 0))
        (dolist (line lines)
          (cond
           ((string-match "^[ \t]*#\\+title:[ \t]*\\(.*\\)$" line)
            (with-current-buffer output-buf (insert (match-string 1 line) "\n")))
           ((and in-code-block (string-match-p "^[ \t]*#\\+END_SRC[ \t]*$" line))
            (setq in-code-block nil)
            (with-current-buffer output-buf (insert (funcall make-prefix 'text idx) "#[endcode]\n")))
           ((and (not in-code-block) (string-match "^[ \t]*#\\+BEGIN_SRC[ \t]+\\(.*\\)$" line))
            (setq in-code-block t)
            (with-current-buffer output-buf (insert (funcall make-prefix 'text idx) "#[code " (match-string 1 line) "]\n")))
           ((and (not in-code-block) (string-match "^\\(\\*+\\)[ \t]+\\(.*?\\)[ \t]*--[ \t]*\\(.*\\)$" line))
            (let* ((stars (match-string 1 line)) (file (match-string 2 line)) (desc (match-string 3 line)) (level (length stars)))
              (setq current-level level)
              (aset is-last-at-level level (gethash idx last-sibling-hash))
              (with-current-buffer output-buf (insert (funcall make-prefix 'node idx) file "  # " desc "\n"))))
           ((and (not in-code-block) (string-match "^\\(\\*+\\)[ \t]+\\(.*\\)$" line))
            (let* ((stars (match-string 1 line)) (file (match-string 2 line)) (level (length stars)))
              (setq current-level level)
              (aset is-last-at-level level (gethash idx last-sibling-hash))
              (with-current-buffer output-buf (insert (funcall make-prefix 'node idx) file "\n"))))
           ((and (not in-code-block) (string-match-p "^[ \t]*:[ \t]*$" line))
            (with-current-buffer output-buf (insert (funcall make-prefix 'text idx) "#\n")))
           ((string-match-p "^[ \t]*$" line)
            (with-current-buffer output-buf
              (let ((prefix (replace-regexp-in-string "[ \t]+$" "" (funcall make-prefix (if in-code-block 'text 'blank) idx))))
                (if (string= prefix "") (insert "\n") (insert prefix "\n")))))
           (t
            (let ((content line))
              (unless in-code-block (setq content (replace-regexp-in-string "^[ \t]\\{1,4\\}" "" content)))
              (with-current-buffer output-buf (insert (funcall make-prefix 'text idx) "# " content "\n")))))
          (setq idx (1+ idx)))))
    (switch-to-buffer output-buf)))

(provide 'ascii-tree)
;;; ascii-tree.el ends here
